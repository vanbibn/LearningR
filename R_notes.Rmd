---
title: "R Programming Notes"
author: "Nathan W. Van Bibber"
date: "1/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}

```

# Functions to Know as Learning R #############################################

## Packages ===================================================================

```{r}
strinstalled.packages() #check what packages are installed
library()
old.packages() #check what packages need to update
```

## Session Info and Help ======================================================
```{r}
version
sessionInfo()
help() # shortcut is to just use ? at start of line
help.search("") # searches through R's documentation (?? is shortcut)
help(package = 'ggplot2')
browseVignettes('ggplot2')

str() #displays the internal structure of any R object
example() # runs code from Examples section of Help

vector('numeric', length = 10) #creates vector (0 is default value)
```

### Ways to create a matrix: --------------------------------------------------
```{r}
m1 <- matrix(1:6, nrow = 2,ncol = 3) #filled collumn-wise
m2 <- 1:10
dim(m2) <- c(2,5)
x4 <- 1:3
y4 <- 10:12
cbind(x4,y4)
rbind(x4,y4)
```


### Reading tabular data  -----------------------------------------------------
Read the help page for `read.table`. 
**Memorize!** - allows you to optimize how to read large datasets

```{r}
?read.table
```
 
Eg. optimize: 
    * comment.char: set to empty string "" if no comments in file  
    * nrows: for large files pre-set to slightly larger number than needed  
    * colClasses: specifying instead of using default can make 2x faster!  
        + Must know the class of each column (see example below)
        
```{r}
initial <- read.table("datatable.txt", nrows = 100)
classes <- sapply(initial, class)
tabAll <- read.table("datatable.txt", colClasses = classes)
```
        
How much memory needed to read in data? Make sure less than RAM available!
$ RAM = 2 * ((#row * #col * 8bytes)/(2^30 bytes/GB))$
    (double to account for overhead in reading data in)
Know your: OS, memory size, 64/32bit, other apps open or users logged in  

## Workspace and Files =======================================================

Before running a program that loops through a series of files you will want to first check to see if each file exists
```{r}
getwd()
dir.create('testdir')
setwd("testdir")
file.create("mytest.R")
list.files()
file.exists('mytest.R')
```

 

file.info('mytest.R')  #use "\$" to grab spec field eg. 
```{r}
file.info("mytest.R")$mode
```


Construct file and directory paths that are independent of the operating sys
```{r}
dir.create(file.path('testdir2','testdir3'), recursive = TRUE)
```


It is helpful to save the initial settings before you began an analysis and go back to them at the end. -- This trick is often used within functions too.

"Take nothing but results. Leave nothing but assumptions." (what does this even mean?)


## Sequences of Numbers =======================================================
```{r}
1:20
?`:`  # `backtick` key is above Tab
seq(1,20)
seq(0,10,0.5)
my_seq <- seq(5,10, length.out = 30)
length(my_seq)
1:length(my_seq)
seq(along = my_seq)
seq_along(my_seq)
rep(0, times = 40)
rep(c(0,1,2), times = 10)
rep(c(0,1,2), each = 10)
```


## Vectors ====================================================================

```{r}
num_vect <- c(0.5,55,-10,6)
tf <- num_vect < 1
```


#logicls
& = AND
| = OR
```{r}
(3 > 5) & (4 == 4)
(TRUE == TRUE) | (TRUE == FALSE) # | = OR
((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
```


# character vectors
```{r}
my_char <- c("My","name","is")
paste(my_char, collapse = " ")
my_name <- c(my_char, "Nathan")
paste(my_name, collapse = " ")
paste('Hello','world!', sep = ' ')
paste(1:3,c('X','Y','Z'), sep = "")
```


## Missing Values =============================================================

NA is used to represent any value that is 'not available' or 'missing'

NA is not a value, it is placeholder for a quantity that is not available. Therefore the logical expressions will not work as expected!!

R represents TRUE as 1 and FALSE as 0 so... sum of a bunch of TRUEs and FALSEs = total number of TRUEs.


```{r}
x <- c(44, NA, 5, NA)
x * 3

# take a random sample of numbers and NA's
y <- rnorm(1000)
z <- rep(NA, 1000)

my_data <- sample(c(y,z), 100)
my_na <- is.na(my_data)
sum(my_na) # counts num of TRUE's ie. # NA values

# use subsetting to remove missing values from my_data
my_data[!my_na]
```


NaN stands for "not a number"
```{r}
0/0  #NaN
Inf - Inf  #NaN
```


## Subsetting Vectors ========================================================

To select a subset of elements use an 'index vector' in [] after vname
4 diff flavors of index vectors: logical, (+ or -)integers, character strings

```{r}
x[1:10]
x[!is.na(x)]
x[!is.na(x) & x > 0]
x[c(3,5,7)]
x[-c(2,10)] # all except index 2 and index 10 == x[c(-2,-10)]
```


# create a vector with named elements
```{r}
vect <- c(foo = 11, bar = 2, norf = NA)
vect2 <- c(11,2,NA)
names(vect2) <- c("foo", "bar", "norf") # names can be added after the fact
identical(vect,vect2)
vect2["bar"]
vect[c("foo", "bar")]
```


## Matrices and Data Frames  ==================================================

```{r}
my_vector <-  1:20
dim(my_vector)
length(my_vector)
dim(my_vector) <- c(4,5)
dim(my_vector)
attributes(my_vector)
class(my_vector)
my_data <- data.frame(patients, my_matrix)
cnames <- c("patient", "age", "weight", "bp", "rating", "test")
colnames(my_data) <- cnames

good <- complete.cases()
```


## Dates and Times  ===========================================================
Dates use the Date class
Times use POSIXct and POSIXlt classes

```{r}
strptime()
as.Date()
as.POSIXct()
as.POSIXlt()
```


## Logicals ===================================================================

```{r}
identical()
isTRUE()
xor()  # exclusive OR (T | T --> FALSE)
which()
any()
all()
```


## Loop Functions =============================================================

```{r}
lapply()
apply()
mapply()
tapply()

split()
```


## Debugging ===============================================================
Three main indications of a problem: `message`, `warning`, `error`
    * Only `error` is fatal (will stop execution)

Questions to ask yourself when something goes wrong:
    * What was your input?  
    * How did you call the function?  
    * What were you expecting?  
    * What did you get?  
        + Output messages or other results?  
        + How does what you got differ from what you were expecting?  
    * Were your expectations correct in the first place?  
    * Can you reproduce the problem (exactly)?  
        + Important for getting help!

```{r}
traceback() # Prints out fn call stack
recover()   # error handler: stops execution at error and opens fn call stack

debug()     # allows you step through a fn 1 line at a time
browser()   # suspends execution and puts fn in "debug" mode
trace()     # insert debugging code into fn w/o editing fn itself

print()
cat()
```

